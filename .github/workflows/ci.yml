# =============================================================================
# ci.yml — CI workflow matrix for asx (bd-66l.1)
#
# Jobs mirror the gate structure from AGENTS.md section "CI/CD Pipeline":
#   check            format + lint + strict build                    (blocking)
#   unit-invariant   module + invariant test suites                  (blocking)
#   conformance      Rust fixture parity + codec equivalence         (blocking)
#   profile-parity   cross-profile semantic digest parity            (blocking)
#   fuzz-parity      differential fuzzing smoke + minimization check (blocking)
#   embedded-matrix  router-class cross-target builds + QEMU         (blocking)
#   e2e              canonical e2e scenario suite with manifest      (blocking)
#
# Triggers: pull_request, push to main
# =============================================================================

name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read

env:
  FAIL_ON_MISSING_RUNNERS: 0
  FAIL_ON_MISSING_CROSS_TOOLCHAINS: 0
  CI: 1
  ASX_CI_RUN_TAG: "${{ github.run_id }}-${{ github.run_attempt }}"
  ASX_CI_ARTIFACT_ROOT: build/ci-manifests

jobs:
  # ---------------------------------------------------------------------------
  # check — format + lint + strict build (warnings-as-errors)
  # ---------------------------------------------------------------------------
  check:
    name: "check (format + lint + build)"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq cppcheck clang-format jq

      - name: Format check
        id: format_check
        run: make format-check

      - name: Lint (cppcheck)
        id: lint_cppcheck
        run: make lint

      - name: Lint (API docs)
        id: lint_docs
        run: make lint-docs

      - name: Lint (checkpoint coverage)
        id: lint_checkpoint
        run: make lint-checkpoint

      - name: Lint (anti-butchering proof block)
        id: lint_anti_butchering
        run: make lint-anti-butchering

      - name: Static analysis (section 10.7)
        id: lint_static_analysis
        run: make lint-static-analysis

      - name: Build (strict warnings-as-errors)
        id: build
        run: make build

      - name: Bounded model-check (state machines)
        id: model_check
        run: make model-check

      - name: Emit check lane manifest
        if: always()
        run: |
          mkdir -p "${ASX_CI_ARTIFACT_ROOT}"
          lane="check"
          first_failure=""
          rerun=""

          if [ "${{ steps.format_check.outcome }}" = "failure" ]; then
            first_failure="format-check"
            rerun="make format-check"
          elif [ "${{ steps.lint_cppcheck.outcome }}" = "failure" ]; then
            first_failure="lint"
            rerun="make lint"
          elif [ "${{ steps.lint_docs.outcome }}" = "failure" ]; then
            first_failure="lint-docs"
            rerun="make lint-docs"
          elif [ "${{ steps.lint_checkpoint.outcome }}" = "failure" ]; then
            first_failure="lint-checkpoint"
            rerun="make lint-checkpoint"
          elif [ "${{ steps.lint_anti_butchering.outcome }}" = "failure" ]; then
            first_failure="lint-anti-butchering"
            rerun="make lint-anti-butchering"
          elif [ "${{ steps.build.outcome }}" = "failure" ]; then
            first_failure="build"
            rerun="make build"
          fi

          status="pass"
          if [ -n "$first_failure" ]; then
            status="fail"
          fi

          jq -n \
            --arg lane "$lane" \
            --arg status "$status" \
            --arg run_tag "${{ env.ASX_CI_RUN_TAG }}" \
            --arg workflow "${{ github.workflow }}" \
            --arg sha "${{ github.sha }}" \
            --arg ref "${{ github.ref }}" \
            --arg format_outcome "${{ steps.format_check.outcome }}" \
            --arg lint_outcome "${{ steps.lint_cppcheck.outcome }}" \
            --arg lint_docs_outcome "${{ steps.lint_docs.outcome }}" \
            --arg lint_checkpoint_outcome "${{ steps.lint_checkpoint.outcome }}" \
            --arg lint_anti_butchering_outcome "${{ steps.lint_anti_butchering.outcome }}" \
            --arg build_outcome "${{ steps.build.outcome }}" \
            --arg first_failure "$first_failure" \
            --arg rerun "$rerun" \
            '{
              lane: $lane,
              status: $status,
              run_tag: $run_tag,
              workflow: $workflow,
              sha: $sha,
              ref: $ref,
              steps: [
                {id: "format-check", outcome: $format_outcome, rerun: "make format-check"},
                {id: "lint", outcome: $lint_outcome, rerun: "make lint"},
                {id: "lint-docs", outcome: $lint_docs_outcome, rerun: "make lint-docs"},
                {id: "lint-checkpoint", outcome: $lint_checkpoint_outcome, rerun: "make lint-checkpoint"},
                {id: "lint-anti-butchering", outcome: $lint_anti_butchering_outcome, rerun: "make lint-anti-butchering"},
                {id: "build", outcome: $build_outcome, rerun: "make build"}
              ],
              first_failure: (if $first_failure == "" then null else {step: $first_failure, rerun: $rerun} end)
            }' > "${ASX_CI_ARTIFACT_ROOT}/${lane}.manifest.json"

      - name: Upload check artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: check-${{ env.ASX_CI_RUN_TAG }}
          path: |
            build/
            ${{ env.ASX_CI_ARTIFACT_ROOT }}/check.manifest.json
          retention-days: 7

  # ---------------------------------------------------------------------------
  # unit-invariant — module + invariant + API ergonomics vignette suites
  # ---------------------------------------------------------------------------
  unit-invariant:
    name: "unit + invariant + vignettes"
    runs-on: ubuntu-latest
    needs: [check]
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq jq

      - name: Build
        id: build
        run: make build

      - name: Unit tests
        id: unit_tests
        run: make test-unit

      - name: Invariant tests
        id: invariant_tests
        run: make test-invariants

      - name: API ergonomics vignettes
        id: vignette_tests
        run: make test-vignettes

      - name: Validate structured test logs
        id: validate_logs
        run: tools/ci/validate_test_logs.sh --strict

      - name: Emit unit+invariant lane manifest
        if: always()
        run: |
          mkdir -p "${ASX_CI_ARTIFACT_ROOT}"
          lane="unit-invariant"
          first_failure=""
          rerun=""

          if [ "${{ steps.build.outcome }}" = "failure" ]; then
            first_failure="build"
            rerun="make build"
          elif [ "${{ steps.unit_tests.outcome }}" = "failure" ]; then
            first_failure="test-unit"
            rerun="make test-unit"
          elif [ "${{ steps.invariant_tests.outcome }}" = "failure" ]; then
            first_failure="test-invariants"
            rerun="make test-invariants"
          elif [ "${{ steps.vignette_tests.outcome }}" = "failure" ]; then
            first_failure="test-vignettes"
            rerun="make test-vignettes"
          elif [ "${{ steps.validate_logs.outcome }}" = "failure" ]; then
            first_failure="validate-test-logs"
            rerun="tools/ci/validate_test_logs.sh --strict"
          fi

          status="pass"
          if [ -n "$first_failure" ]; then
            status="fail"
          fi

          jq -n \
            --arg lane "$lane" \
            --arg status "$status" \
            --arg run_tag "${{ env.ASX_CI_RUN_TAG }}" \
            --arg workflow "${{ github.workflow }}" \
            --arg sha "${{ github.sha }}" \
            --arg ref "${{ github.ref }}" \
            --arg build_outcome "${{ steps.build.outcome }}" \
            --arg unit_outcome "${{ steps.unit_tests.outcome }}" \
            --arg invariant_outcome "${{ steps.invariant_tests.outcome }}" \
            --arg vignette_outcome "${{ steps.vignette_tests.outcome }}" \
            --arg validate_outcome "${{ steps.validate_logs.outcome }}" \
            --arg first_failure "$first_failure" \
            --arg rerun "$rerun" \
            '{
              lane: $lane,
              status: $status,
              run_tag: $run_tag,
              workflow: $workflow,
              sha: $sha,
              ref: $ref,
              steps: [
                {id: "build", outcome: $build_outcome, rerun: "make build"},
                {id: "test-unit", outcome: $unit_outcome, rerun: "make test-unit"},
                {id: "test-invariants", outcome: $invariant_outcome, rerun: "make test-invariants"},
                {id: "test-vignettes", outcome: $vignette_outcome, rerun: "make test-vignettes"},
                {id: "validate-test-logs", outcome: $validate_outcome, rerun: "tools/ci/validate_test_logs.sh --strict"}
              ],
              first_failure: (if $first_failure == "" then null else {step: $first_failure, rerun: $rerun} end)
            }' > "${ASX_CI_ARTIFACT_ROOT}/${lane}.manifest.json"

      - name: Upload unit+invariant artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-invariant-${{ env.ASX_CI_RUN_TAG }}
          path: |
            build/test/
            build/tests/
            build/test-logs/
            tools/ci/artifacts/
            ${{ env.ASX_CI_ARTIFACT_ROOT }}/unit-invariant.manifest.json
          retention-days: 7

  # ---------------------------------------------------------------------------
  # e2e — canonical e2e scenario suite with deterministic run-manifest
  # ---------------------------------------------------------------------------
  e2e:
    name: "e2e scenario suite"
    runs-on: ubuntu-latest
    needs: [check]
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq jq

      - name: Build
        id: build
        run: make build

      - name: Run e2e suite with manifest
        id: run_e2e_suite
        run: make test-e2e-suite

      - name: Run vertical e2e lanes (HFT/automotive/continuity)
        id: run_e2e_vertical
        run: make test-e2e-vertical

      - name: Validate e2e manifest publication
        id: validate_manifest
        run: |
          shopt -s nullglob
          manifests=(build/e2e-artifacts/*/run_manifest.json)
          if [ "${#manifests[@]}" -eq 0 ]; then
            echo "[asx] e2e: FAIL — no run_manifest.json found under build/e2e-artifacts/*" >&2
            exit 1
          fi
          printf '[asx] e2e: found %d run manifest(s)\n' "${#manifests[@]}"
          printf '%s\n' "${manifests[@]}"

      - name: Emit e2e lane manifest
        if: always()
        run: |
          mkdir -p "${ASX_CI_ARTIFACT_ROOT}"
          lane="e2e"
          first_failure=""
          rerun=""

          if [ "${{ steps.build.outcome }}" = "failure" ]; then
            first_failure="build"
            rerun="make build"
          elif [ "${{ steps.run_e2e_suite.outcome }}" = "failure" ]; then
            first_failure="test-e2e-suite"
            rerun="make test-e2e-suite"
          elif [ "${{ steps.run_e2e_vertical.outcome }}" = "failure" ]; then
            first_failure="test-e2e-vertical"
            rerun="make test-e2e-vertical"
          elif [ "${{ steps.validate_manifest.outcome }}" = "failure" ]; then
            first_failure="validate-e2e-manifest"
            rerun="find build/e2e-artifacts -name run_manifest.json"
          fi

          status="pass"
          if [ -n "$first_failure" ]; then
            status="fail"
          fi

          jq -n \
            --arg lane "$lane" \
            --arg status "$status" \
            --arg run_tag "${{ env.ASX_CI_RUN_TAG }}" \
            --arg workflow "${{ github.workflow }}" \
            --arg sha "${{ github.sha }}" \
            --arg ref "${{ github.ref }}" \
            --arg build_outcome "${{ steps.build.outcome }}" \
            --arg e2e_suite_outcome "${{ steps.run_e2e_suite.outcome }}" \
            --arg e2e_vertical_outcome "${{ steps.run_e2e_vertical.outcome }}" \
            --arg validate_outcome "${{ steps.validate_manifest.outcome }}" \
            --arg first_failure "$first_failure" \
            --arg rerun "$rerun" \
            '{
              lane: $lane,
              status: $status,
              run_tag: $run_tag,
              workflow: $workflow,
              sha: $sha,
              ref: $ref,
              steps: [
                {id: "build", outcome: $build_outcome, rerun: "make build"},
                {id: "test-e2e-suite", outcome: $e2e_suite_outcome, rerun: "make test-e2e-suite"},
                {id: "test-e2e-vertical", outcome: $e2e_vertical_outcome, rerun: "make test-e2e-vertical"},
                {id: "validate-e2e-manifest", outcome: $validate_outcome, rerun: "find build/e2e-artifacts -name run_manifest.json"}
              ],
              first_failure: (if $first_failure == "" then null else {step: $first_failure, rerun: $rerun} end)
            }' > "${ASX_CI_ARTIFACT_ROOT}/${lane}.manifest.json"

      - name: Upload e2e artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-${{ env.ASX_CI_RUN_TAG }}
          path: |
            build/e2e-artifacts/
            build/test-logs/
            ${{ env.ASX_CI_ARTIFACT_ROOT }}/e2e.manifest.json
          retention-days: 7

  # ---------------------------------------------------------------------------
  # conformance — Rust fixture parity + codec equivalence
  # ---------------------------------------------------------------------------
  conformance:
    name: "conformance (Rust parity + codec equiv)"
    runs-on: ubuntu-latest
    needs: [check]
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq jq

      - name: Build
        id: build
        run: make build

      - name: Rust fixture conformance
        id: run_conformance
        run: make conformance

      - name: Codec equivalence (JSON vs BIN)
        id: run_codec_equivalence
        run: make codec-equivalence

      - name: Validate conformance summaries
        id: validate_manifest
        run: |
          summary_count="$(find tools/ci/artifacts/conformance -maxdepth 1 -type f -name '*.summary.json' | wc -l | tr -d ' ')"
          if [ "$summary_count" -lt 2 ]; then
            echo "[asx] conformance: FAIL — expected at least 2 summary files, found $summary_count" >&2
            exit 1
          fi
          printf '[asx] conformance: summary files found=%s\n' "$summary_count"

          semantic_delta_count="$(find build/conformance -maxdepth 1 -type f -name 'semantic_delta_*.json' | wc -l | tr -d ' ')"
          if [ "$semantic_delta_count" -lt 2 ]; then
            echo "[asx] conformance: FAIL — expected semantic delta artifacts for conformance + codec-equivalence runs" >&2
            exit 1
          fi
          printf '[asx] conformance: semantic delta artifacts found=%s\n' "$semantic_delta_count"

      - name: Emit conformance lane manifest
        if: always()
        run: |
          mkdir -p "${ASX_CI_ARTIFACT_ROOT}"
          lane="conformance"
          first_failure=""
          rerun=""

          if [ "${{ steps.build.outcome }}" = "failure" ]; then
            first_failure="build"
            rerun="make build"
          elif [ "${{ steps.run_conformance.outcome }}" = "failure" ]; then
            first_failure="conformance"
            rerun="make conformance"
          elif [ "${{ steps.run_codec_equivalence.outcome }}" = "failure" ]; then
            first_failure="codec-equivalence"
            rerun="make codec-equivalence"
          elif [ "${{ steps.validate_manifest.outcome }}" = "failure" ]; then
            first_failure="validate-conformance-summaries"
            rerun="find tools/ci/artifacts/conformance -name '*.summary.json'"
          fi

          status="pass"
          if [ -n "$first_failure" ]; then
            status="fail"
          fi

          jq -n \
            --arg lane "$lane" \
            --arg status "$status" \
            --arg run_tag "${{ env.ASX_CI_RUN_TAG }}" \
            --arg workflow "${{ github.workflow }}" \
            --arg sha "${{ github.sha }}" \
            --arg ref "${{ github.ref }}" \
            --arg build_outcome "${{ steps.build.outcome }}" \
            --arg conformance_outcome "${{ steps.run_conformance.outcome }}" \
            --arg codec_outcome "${{ steps.run_codec_equivalence.outcome }}" \
            --arg validate_outcome "${{ steps.validate_manifest.outcome }}" \
            --arg first_failure "$first_failure" \
            --arg rerun "$rerun" \
            '{
              lane: $lane,
              status: $status,
              run_tag: $run_tag,
              workflow: $workflow,
              sha: $sha,
              ref: $ref,
              steps: [
                {id: "build", outcome: $build_outcome, rerun: "make build"},
                {id: "conformance", outcome: $conformance_outcome, rerun: "make conformance"},
                {id: "codec-equivalence", outcome: $codec_outcome, rerun: "make codec-equivalence"},
                {id: "validate-conformance-summaries", outcome: $validate_outcome, rerun: "find tools/ci/artifacts/conformance -name '*.summary.json'"}
              ],
              first_failure: (if $first_failure == "" then null else {step: $first_failure, rerun: $rerun} end)
            }' > "${ASX_CI_ARTIFACT_ROOT}/${lane}.manifest.json"

      - name: Upload conformance reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: conformance-${{ env.ASX_CI_RUN_TAG }}
          path: |
            tools/ci/artifacts/conformance/
            ${{ env.ASX_CI_ARTIFACT_ROOT }}/conformance.manifest.json
          retention-days: 14

  # ---------------------------------------------------------------------------
  # profile-parity — cross-profile canonical digest parity
  # ---------------------------------------------------------------------------
  profile-parity:
    name: "profile parity"
    runs-on: ubuntu-latest
    needs: [check]
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq jq

      - name: Build
        id: build
        run: make build

      - name: Profile parity check
        id: run_profile_parity
        run: make profile-parity

      - name: Validate profile parity summary
        id: validate_manifest
        run: |
          summary_count="$(find tools/ci/artifacts/conformance -maxdepth 1 -type f -name '*-profile-parity.summary.json' | wc -l | tr -d ' ')"
          if [ "$summary_count" -lt 1 ]; then
            echo "[asx] profile-parity: FAIL — expected profile-parity summary file" >&2
            exit 1
          fi
          printf '[asx] profile-parity: summary files found=%s\n' "$summary_count"

          semantic_delta_count="$(find build/conformance -maxdepth 1 -type f -name 'semantic_delta_*.json' | wc -l | tr -d ' ')"
          if [ "$semantic_delta_count" -lt 1 ]; then
            echo "[asx] profile-parity: FAIL — expected semantic delta artifact output" >&2
            exit 1
          fi
          printf '[asx] profile-parity: semantic delta artifacts found=%s\n' "$semantic_delta_count"

      - name: Emit profile parity lane manifest
        if: always()
        run: |
          mkdir -p "${ASX_CI_ARTIFACT_ROOT}"
          lane="profile-parity"
          first_failure=""
          rerun=""

          if [ "${{ steps.build.outcome }}" = "failure" ]; then
            first_failure="build"
            rerun="make build"
          elif [ "${{ steps.run_profile_parity.outcome }}" = "failure" ]; then
            first_failure="profile-parity"
            rerun="make profile-parity"
          elif [ "${{ steps.validate_manifest.outcome }}" = "failure" ]; then
            first_failure="validate-profile-parity-summary"
            rerun="find tools/ci/artifacts/conformance -name '*-profile-parity.summary.json'"
          fi

          status="pass"
          if [ -n "$first_failure" ]; then
            status="fail"
          fi

          jq -n \
            --arg lane "$lane" \
            --arg status "$status" \
            --arg run_tag "${{ env.ASX_CI_RUN_TAG }}" \
            --arg workflow "${{ github.workflow }}" \
            --arg sha "${{ github.sha }}" \
            --arg ref "${{ github.ref }}" \
            --arg build_outcome "${{ steps.build.outcome }}" \
            --arg parity_outcome "${{ steps.run_profile_parity.outcome }}" \
            --arg validate_outcome "${{ steps.validate_manifest.outcome }}" \
            --arg first_failure "$first_failure" \
            --arg rerun "$rerun" \
            '{
              lane: $lane,
              status: $status,
              run_tag: $run_tag,
              workflow: $workflow,
              sha: $sha,
              ref: $ref,
              steps: [
                {id: "build", outcome: $build_outcome, rerun: "make build"},
                {id: "profile-parity", outcome: $parity_outcome, rerun: "make profile-parity"},
                {id: "validate-profile-parity-summary", outcome: $validate_outcome, rerun: "find tools/ci/artifacts/conformance -name '*-profile-parity.summary.json'"}
              ],
              first_failure: (if $first_failure == "" then null else {step: $first_failure, rerun: $rerun} end)
            }' > "${ASX_CI_ARTIFACT_ROOT}/${lane}.manifest.json"

      - name: Upload parity reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: profile-parity-${{ env.ASX_CI_RUN_TAG }}
          path: |
            tools/ci/artifacts/conformance/
            ${{ env.ASX_CI_ARTIFACT_ROOT }}/profile-parity.manifest.json
          retention-days: 14

  # ---------------------------------------------------------------------------
  # fuzz-parity — differential fuzzing smoke + minimization check
  # ---------------------------------------------------------------------------
  fuzz-parity:
    name: "differential fuzz smoke"
    runs-on: ubuntu-latest
    needs: [check]
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq jq

      - name: Build fuzz harness
        id: build_fuzz
        run: make fuzz-build

      - name: Fuzz smoke test
        id: run_fuzz_smoke
        run: make fuzz-smoke

      - name: Validate fuzz artifacts
        id: validate_manifest
        run: |
          if [ ! -x build/fuzz/fuzz_differential ]; then
            echo "[asx] fuzz-parity: FAIL — missing build/fuzz/fuzz_differential" >&2
            exit 1
          fi

      - name: Emit fuzz lane manifest
        if: always()
        run: |
          mkdir -p "${ASX_CI_ARTIFACT_ROOT}"
          lane="fuzz-parity"
          first_failure=""
          rerun=""

          if [ "${{ steps.build_fuzz.outcome }}" = "failure" ]; then
            first_failure="fuzz-build"
            rerun="make fuzz-build"
          elif [ "${{ steps.run_fuzz_smoke.outcome }}" = "failure" ]; then
            first_failure="fuzz-smoke"
            rerun="make fuzz-smoke"
          elif [ "${{ steps.validate_manifest.outcome }}" = "failure" ]; then
            first_failure="validate-fuzz-artifacts"
            rerun="ls -la build/fuzz"
          fi

          status="pass"
          if [ -n "$first_failure" ]; then
            status="fail"
          fi

          jq -n \
            --arg lane "$lane" \
            --arg status "$status" \
            --arg run_tag "${{ env.ASX_CI_RUN_TAG }}" \
            --arg workflow "${{ github.workflow }}" \
            --arg sha "${{ github.sha }}" \
            --arg ref "${{ github.ref }}" \
            --arg build_outcome "${{ steps.build_fuzz.outcome }}" \
            --arg smoke_outcome "${{ steps.run_fuzz_smoke.outcome }}" \
            --arg validate_outcome "${{ steps.validate_manifest.outcome }}" \
            --arg first_failure "$first_failure" \
            --arg rerun "$rerun" \
            '{
              lane: $lane,
              status: $status,
              run_tag: $run_tag,
              workflow: $workflow,
              sha: $sha,
              ref: $ref,
              steps: [
                {id: "fuzz-build", outcome: $build_outcome, rerun: "make fuzz-build"},
                {id: "fuzz-smoke", outcome: $smoke_outcome, rerun: "make fuzz-smoke"},
                {id: "validate-fuzz-artifacts", outcome: $validate_outcome, rerun: "ls -la build/fuzz"}
              ],
              first_failure: (if $first_failure == "" then null else {step: $first_failure, rerun: $rerun} end)
            }' > "${ASX_CI_ARTIFACT_ROOT}/${lane}.manifest.json"

      - name: Upload fuzz artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: fuzz-parity-${{ env.ASX_CI_RUN_TAG }}
          path: |
            build/fuzz/
            ${{ env.ASX_CI_ARTIFACT_ROOT }}/fuzz-parity.manifest.json
          retention-days: 7

  # ---------------------------------------------------------------------------
  # compiler-matrix — GCC + Clang across profiles
  # ---------------------------------------------------------------------------
  compiler-matrix:
    name: "compiler matrix (${{ matrix.compiler }}, ${{ matrix.profile }})"
    runs-on: ubuntu-latest
    needs: [check]
    strategy:
      fail-fast: false
      matrix:
        compiler: [gcc, clang]
        profile: [CORE, POSIX, FREESTANDING, EMBEDDED_ROUTER]
    steps:
      - uses: actions/checkout@v4

      - name: Install Clang
        if: matrix.compiler == 'clang'
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq clang

      - name: Build (${{ matrix.compiler }}, ${{ matrix.profile }})
        run: make build CC=${{ matrix.compiler }} PROFILE=${{ matrix.profile }}

      - name: Test (${{ matrix.compiler }}, ${{ matrix.profile }})
        run: make test-unit CC=${{ matrix.compiler }} PROFILE=${{ matrix.profile }}

  # ---------------------------------------------------------------------------
  # embedded-matrix — router-class cross-target builds + QEMU
  # ---------------------------------------------------------------------------
  embedded-matrix:
    name: "embedded matrix"
    runs-on: ubuntu-latest
    needs: [check]
    steps:
      - uses: actions/checkout@v4

      - name: Install cross-compilation toolchains
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq \
            gcc-mipsel-linux-gnu \
            gcc-arm-linux-gnueabi \
            gcc-aarch64-linux-gnu \
            qemu-user-static \
            jq

      - name: Run embedded build matrix
        id: run_embedded_matrix
        run: make ci-embedded-matrix
        env:
          FAIL_ON_MISSING_CROSS_TOOLCHAINS: 0

      - name: Validate embedded matrix artifacts
        id: validate_manifest
        run: |
          jsonl_count="$(find tools/ci/artifacts/build -maxdepth 1 -type f -name '*.jsonl' | wc -l | tr -d ' ')"
          if [ "$jsonl_count" -lt 1 ]; then
            echo "[asx] embedded-matrix: FAIL — expected at least one JSONL build artifact" >&2
            exit 1
          fi
          printf '[asx] embedded-matrix: JSONL artifacts found=%s\n' "$jsonl_count"

      - name: Emit embedded lane manifest
        if: always()
        run: |
          mkdir -p "${ASX_CI_ARTIFACT_ROOT}"
          lane="embedded-matrix"
          first_failure=""
          rerun=""

          if [ "${{ steps.run_embedded_matrix.outcome }}" = "failure" ]; then
            first_failure="ci-embedded-matrix"
            rerun="make ci-embedded-matrix"
          elif [ "${{ steps.validate_manifest.outcome }}" = "failure" ]; then
            first_failure="validate-embedded-artifacts"
            rerun="find tools/ci/artifacts/build -name '*.jsonl'"
          fi

          status="pass"
          if [ -n "$first_failure" ]; then
            status="fail"
          fi

          jq -n \
            --arg lane "$lane" \
            --arg status "$status" \
            --arg run_tag "${{ env.ASX_CI_RUN_TAG }}" \
            --arg workflow "${{ github.workflow }}" \
            --arg sha "${{ github.sha }}" \
            --arg ref "${{ github.ref }}" \
            --arg run_outcome "${{ steps.run_embedded_matrix.outcome }}" \
            --arg validate_outcome "${{ steps.validate_manifest.outcome }}" \
            --arg first_failure "$first_failure" \
            --arg rerun "$rerun" \
            '{
              lane: $lane,
              status: $status,
              run_tag: $run_tag,
              workflow: $workflow,
              sha: $sha,
              ref: $ref,
              steps: [
                {id: "ci-embedded-matrix", outcome: $run_outcome, rerun: "make ci-embedded-matrix"},
                {id: "validate-embedded-artifacts", outcome: $validate_outcome, rerun: "find tools/ci/artifacts/build -name '*.jsonl'"}
              ],
              first_failure: (if $first_failure == "" then null else {step: $first_failure, rerun: $rerun} end)
            }' > "${ASX_CI_ARTIFACT_ROOT}/${lane}.manifest.json"

      - name: Upload embedded artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: embedded-matrix-${{ env.ASX_CI_RUN_TAG }}
          path: |
            build/
            tools/ci/artifacts/build/
            ${{ env.ASX_CI_ARTIFACT_ROOT }}/embedded-matrix.manifest.json
          retention-days: 7
